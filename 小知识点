一,作用域与执行上下文
            1. 区别1
              * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
              * 全局执行上下文环境是在全局作用域确定之后, js代码在真正执行之前创建
              * 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建
            2. 区别2
              * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
              * 上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放
            3. 联系
              * 作用域是从属于其所在的执行上下文环境的
              * 全局上下文环境==>全局作用域
              * 函数上下文环境==>对应的函数使用域
  问题:
              1. 有几个作用域?  ---- 1+n  1是window，n定义函数的个数    4个作用域
              2. 产生过几个上下文? ---- 1+n  1是window,n调用函数的次数  4个
              3. 最终有几个上下文对象? ------ 1个 是window


二, 闭包:        常见的场景
                      1.将函数作为另一个函数的调用
                      2.将函数作为一个实参传递给另一个函数
                生命周期:
                    1. 产生（精准）: 内部函数被定义后就立即产生了闭包(并不内部函数调用时才产生)
                    2. 死亡: 在嵌套的内部函数成为垃圾对象时
                    3. return 不是闭包产生的必要条件，但是编码人员，一般会return内部函数。
                              不return内部函数，闭包瞬间产生，但是瞬间死亡
                              return内部函数，让闭包活下来了（活下来才有意义）
三,执行上下文:
          全局执行上下文
            * 在执行全局代码前将window确定为全局执行上下文
            * 对全局数据进行预处理(预处理)：
                  * var定义的全局变量，提前定义(声明)，值为undefined，是添加为window的属性
                  * function声明的全局函数，提前定义(声明)，添加为window的方法
                  * this ==> 赋值为window
            * 开始执行全局代码

          3. 函数执行上下文：
            * 在调用函数时, 准备执行函数之前, 会创建该函数所对应的执行上下文
            * 对局部数据开始进行预处理：
                  * 形参变量 ==> 赋值为实参 ==> 将形参定义在该函数对应的执行上下文区域内
                  * arguments ==>赋值为实参列表, 定义在该函数对应的执行上下文区域内
                  * var定义的局部变量 ==> 赋值为undefined, 定义在该函数对应的执行上下文区域内
                  * function声明的函数 ==>赋值(函数体内容), 定义在该函数对应的执行上下文区域内
                  * this ==> 赋值(调用函数的对象)
            * 开始执行函数体代码

执行上下文栈:
         1. 在全局代码执行前, JS引擎就会创建一个栈结构来存储和管理所有的【执行上下文】
            2. 在全局执行上下文(window所对应的)确定后, 将其添加到栈中(压栈)，此时栈底的是全局【执行上下文】
            3. 在函数执行之前，创建函数的【执行上下文】, 随后压栈
            4. 在当前函数执行完毕后,将该函数的【执行上下文】在栈中移除(出栈)
            5. 当所有的代码执行完后, 栈中只剩下全局【执行上下文】
            备注：执行上下文栈中，栈顶的永远是当前正在执行的函数的【执行上下文】

四,原型对象
      总结:
        * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
        * 实例对象的__proto__属性: 创建对象时自动添加的, 默认值为它构造函数的prototype属性值
        * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之后就可以操作隐式原型了)

        1.关于显式原型(prototype)的问题     给函数的实例对象用
        2.关于隐式原型(__proto__)的问题     当查找实例身上的某个属性的时候用

五, 原本this指向的是window，需要强制修改this的指向，让this指向子类的实例对象
    假继承只是临时借用了父类构造函数里的代码段
    子类的原型成为父类的实例  子类的原型成为new一个父类的构造函数 父类构造函数里边对this做了什么操作 子类都会继承




























